# Chapter05 재귀 알고리즘 - 02 재귀 알고리즘 분석

## 재귀 알고리즘 분석하기
- recur 메서드는 factorial 메서드나 gcd 메서드와 달리 메서드 안에서 재귀 호출을 2회 실행, 이처럼 재귀 호출을 여러 번 실행하는 메서드를 순수(genuinely) 재귀라 함
- recur 메서드를 하향식, 상향식 두 방법으로 분석하겠다.

<br>

### 하향식 분석
- 매개변수 n에 4를 전달하면 recur 메서드는 다음 과정을 순서대로 실행함
  ```
           | 1. recur(3)을 실행
  recur(4) | 2. 4를 출력
           | 3. recur(2)를 실행
  ```
- 가장 위쪽에 위치한 상자의 메서드를 호출하는 것부터 시작하여 계단 식으로  자세히 조사해 나가는 분석 기법을 하향식 분석(top-down analysis)이라고 함
- 꼭대기(top)부터 분석하다 보면 이렇게 같은 메서드를 여러 번 호출할 수 있기 때문에 '하향식 분석이 반드시 효율적이다.'라고 말할 수는 없음

<br>

### 조금만 더! recur(3) 호출을 더 자세히 알아볼까요?
- recur(3)을 호출하면 recur(0)까지는 계속 왼쪽 화살표를 따라 가기 때문에 4를 바로 출력할 수 없음
- recur(0)의 왼쪽 화살표에서 빈 상자를 만나 recur(0)을 호출한 상자로 돌아가 1을 출력
- 이어 일련의 작업 중 하나인 recur(-1)을 호출해 다시 빈 상자를 만나서 돌아오면 비로소 recur(0)을 호출한 상자에서 한 칸 위의 상자로 돌아감

<br>

### 상향식 분석
- 위쪽부터 분석하는 하향식 분석과는 대조적으로 아래쪽부터 쌓아올리며 분석하는 방법이 상향식 분석(bottom-up analysis)
- recur 메서드는 n이 양수일 때만 실행되므로 먼저 recur(1)을 생각해 보곘다. recur(1)을 실행하는 작업은 다음과 같다.
  ```
           | 1. recur(0)을 실행
  recur(1) | 2. 1를 출력
           | 3. recur(-1)를 실행
  ```
  - 여기서 recur(0)과 3의 recur(-1)을 출력할 내용이 없다. 따라서 recur(1)은 1만 출력한다.
- 이 작업을 recur(4)까지 쌓아 올려 설명한 내용이 아래와 같다.
  ```
  recur(-1) : 아무것도 하지 않음
  recur(0) : 아무것도 하지 않음
  ---
  recur(1) : recur(0) + (1) recur(-1) => (1)
  recur(2) : recur(1) + (2) recur(0) => 1 (2)
  recur(3) : recur(2) + (3) recur(1) => 1 2 (3) 1
  recur(4) : recur(3) + (4) recur(2) => 1 2 3 1 (4) 1 2
  ```

<br>

---

<br>

## 재귀 알고리즘의 비재귀적 표현
- recur 메서드를 재귀 호출을 사용하지 않고 비재귀적으로 구현하는 방법을 살펴보겠다.

<br>

### 꼬리 재귀의 제거
- 메서드의 꼬리에서 재귀 호출하는 메서드 recur(n - 2)는 '인수로 n - 2를 전달하여 recur 메서드를 호출한다'는 의미, 이 호출을 다음과 같이 바꿀 수 있다.
  ```
  n 값을 n - 2로 업데이트하고 메서드의 시작 지점으로 돌아갑니다.
  ```
  - 그 결과 메서드 첫 부분의 if가 while로 바뀜
- 이렇게 하면 메서드의 끝 쪽에서 실행하는 꼬리 재귀(tail recursion)를 쉽게 제거할 수 있음

<br>

### 재귀의 제거
- 변수 n값을 출력하기 전에 recur(n - 1)을 먼저 수행해야 하기 때문에 꼬리 재귀와 달리 앞쪽에서 호출되는 메서드는 제거하기가 쉽지 않다.
- 재귀 호출 recur(n - 1)을 다음처럼 바로 바꿀 수 없음
  ```
  n 값을 n - 1로 업데이트하고 메서드의 시작 지점으로 돌아갑니다. <= NG
  ```
- n이 4인 경우 재귀 호출 recur(3)의 처리가 완료되지 않으면 n값인 '4'를 저장해야 한다. 즉, 다음과 같이 처리한다.
  ```
  현재 n 값을 '잠시' 저장한다.
  ```
- recur(n-1)의 처리가 완료된 다음에 n 값을 출력할 때는 다음 과정을 따르게 된
  ```
  저장했던 n을 다시 꺼내 그 값을 출력한다.
  ```
- 이런 문제를 잘 해결할 수 있는 데이터 구조가 스택이다.
- 매개변수 n에 전달받은 값이 0보다 클 경우 다음과 같은 과정이 진행됨
  ```
  (1) n 값을 스택에 푸시
  (2) n 값을 하나 줄여 n - 1로 만듦
  (3) continue 문에 의해 while문의 맨 앞으로 돌아감
  ```
- 매개변수 n에 전달받은 값이 0일 경우 다음과 같은 과정이 진행됨
  ```
  (1) 스택에 팝한 값을 n에 넣음
  (2) n 값을 출력
  (3) n 값을 2 줄여 n - 2로 만듦
  (4) continue 문에 의해 while문의 맨 앞으로 돌아감
  ```

<br>

---

<br>

## 메모화
- recur 메서드는 실행 과정에서 같은 계산을 여러 번 반복하여 수행함
- n의 값이 커지면 반복하는 계산 횟수는 더욱 늘어남
- 메모화(memorization) 기법을 사용하면 동일한 계산을 반복하지 않고 1회만 수행할 수 있다.
- 어떤 문제(이 경우 recur 메서드가 전달받은 n)에 대한 답을 구할 경우 그것을 메모해 둠
- RecurMemo
  - 메모하는 것은 출력할 문자열, 메모를 저장하는 곳은 String형 배열
  - recur가 n에 전달받은 실인수 값과 메모용 배열 memo의 인덱스는 차이가 1 난다.

<br>

### main 메서드에서 메모 준비
- 배열 memo는 main 메서드에서 생성
- 배열을 생성한 단계에서 모든 요소는 기본값 null로 초기화 되어 있다.
- 메모값이 null이라면 '아직 메모를 하지 않았다'라고 할 수 있다.

<br>

### recur 메서드에서 메모 활용
- recur 메서드의 동작이 업데이트될 경우 다음처럼 처리
  ```
  메모가 이미 되어 있는 경우
  메모의 내용 memo[n + 1]을 화면에 그대로 출력하면 처리가 완료됨
  ---
  메모가 아직 되어 있지 않은 경우
  n이 0보다 크면 먼저 기존 프로그램의 recur 메서드와 동일하게 처리함
  처리를 종료한 뒤에 출력한 문자와 동일한 문자열을 메모함
  곧 메모용 배열의 요소 memo[n+1]에 출력한 내용의 문자열을 대입함
  n이 0보다 크지 않다면 n은 0 또는 -1이다. 빈 문자열 ""을 메모함
  ```

<br>

- recur 메서드를 호출한 횟수를 처음 버전과 메모 버전으로 비교한 것
  <table>
    <tr>
      <th>단계</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
    </tr>
    <tr>
      <th>처음 버전</th>
      <td>3</td>
      <td>5</td>
      <td>9</td>
      <td>15</td>
      <td>25</td>
      <td>41</td>
      <td>67</td>
      <td>109</td>
      <td>177</td>
      <td>287</td>
    </tr>
    <tr>
      <th>메모화 버전</th>
      <td>3</td>
      <td>5</td>
      <td>7</td>
      <td>9</td>
      <td>11</td>
      <td>13</td>
      <td>15</td>
      <td>17</td>
      <td>19</td>
      <td>21</td>
    </tr>
  </table>
  - 메모리 버전이 동인한 계산이 반복되지 않아 메서드 호출 횟수가 적은 것을 확인할 수 있다.

<br>

---

<br>

정리한 내용에 대한 저작권은 "[do it! 자료구조와 함께 배우는 알고리즘 입문 자바편 개정](https://www.aladin.co.kr/search/wsearchresult.aspx?SearchTarget=All&SearchWord=Do+it%21+%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80+%ED%95%A8%EA%BB%98+%EB%B0%B0%EC%9A%B0%EB%8A%94+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98+%EC%9E%85%EB%AC%B8+%3A+%EC%9E%90%EB%B0%94+%ED%8E%B8)"에 있습니다.
