# Chapter06 정렬 알고리즘 - 02 버블 정렬
- 버블 정렬은 이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘으로 단순 교환 정렬(straight exchange sort)이라고 함

<br>

## 버블 정렬 알아보기
- {6, 4, 3, 7, 1, 9, 8} 배열을 이용해 버블 정렬(bubble sort)을 알아보겠다.
  - 먼저 끝에 있는 두 요소 9와 8부터 시작, {6, 4, 3, 7, 1, 8, 9}
  - 그 다음 위쪽에서 두 번째와 세 번째 요소인 1과 8을 비교
    - 1은 8보다 작으므로 교환할 필요가 없다.
  - 이렇게 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 {1, 6, 4, 3, 7, 8, 9}가 됨
  - 요솟숙가 n개인 배열에서 n - 1번 비교, 교환하고 나면 가장 작은 요소가 맨 처음으로 이동, 이런 일련의 과정(비교, 교환)을 패스(pass)라고 함
- 이어서 배열의 두 번째 이후 요소를 비교, 교환하는 패스를 수행
  - 이 패스를 수행하고 나면, 3은 배열의 두 번째 자리로 이동하고 그 결과 두 요소의 정렬이 끝남
  - 두번째 패스의 비교횟수는 첫 번째 패스보다 1번 적은 n - 2번
    - 패스를 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문
- 패스를 k번 수행하면 앞쪽부터 k개의 요소가 정렬된다는 것을 알 수 있음
- 모든 정렬이 끝나려면 패스가 n-1번 수행되어야 함

<br>

### 버블 정렬 프로그램 만들기
- 버블 정렬 알고리즘을 프로그램으로 구현해 보겠다.
- 변수 i값을 0부터 n-2까지 1씩 증가시키며 패스를 n-2번 수행하는 프로그램은 다음과 같다.
  ```java
  for(int i=0; i<n-1; i++) {
    // a[i], a[i+1], ... , a[n-1]에 대해
    // 끝에서 부터 앞쪽으로 스캔하면서 이웃하는 두 요소를 비교하고 교환 
  }
  
  ```
- 여기서 비교하는 두 요소를 j-1, i라 하고, 변수 j 값을 어떻게 변화하면 좋을지 살펴보겠다.
- 배열의 끝(오른쪽)부터 스캔하기 때문에 j의 시작점은 n-1
  - 이때 두 요소 (a[j-1], a[j])의 값을 비교하여 앞쪽이 크면 교환
  - 이후의 비교, 교환 과정은 바로 앞쪽에ㅓ 수행해야 하므로 j값은 1씩 감소
- 각 패스에서 앞쪽 1개의 요소는 정렬이 끝난 상태라고 가정(정렬하지 않은 부분은 a[i] ~ a[n-1]이라고 가정)
  - 한 번의 패스에는 j 값이 i+1이 될때까지 비교, 교환을 수행하면 됨
- 서로 한 칸 이상 멀리 떨어져 있는 요소를 교환하는 것이 아니라 서로 이웃한 요소만 교환하므로 이 정렬 알고리즘을 안정적이라고 할 수 있다.
- 첫번째 패스의 비교횟수는 n-1회, 두 번째 패스의 비교 횟수는 n-2회, ... 이므로 그 합계는 다음과 같다.
  ```
  (n-1) + (n-2) + ... + 1 = n(n-1) / 2
  ```
- 그러나 실제 요소를 교환하는 횟수는 배열의 요솟값에 영향을 더 많이 받기 때문에 교환 횟수의 평균값은 비교 횟수의 절반인 n(n-2)/4회
- swap 메서드 안에서 값이 3회 이동(대입)하므로 이동 횟수의 평균은 3n(n-1)/4회

<br>

### 알고리즘 개선하기 1
- BubbleSort에서 3번째 패스까지 교환이 이루어지고 4번째 패스부터는 요소의 교환이 한 번도 이루어지지 않는다. 왜냐하면 3번째 패스에서 정렬을 마쳤기 때문
- 배열이 정렬이 이미 마친 상태라면 그 이후의 패스는 요소를 교환하지 않는다.
- 즉, 어떤 패스에서 요소의 교환 횟수가 0이라면 더 이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈춤
- 이런 멈춤 작업을 도입하면 정렬을 마친 배열이나 정렬이 거의 다 된 상태의 배열에 대한 비교 연산이 많이 생략되어 짧은 시간에 정렬을 마칠 수 있음
- BubbleSort2
  - 변수 exchg를 새롭게 추가
  - 패스를 시작하기 직전에 exchg값을 0으로 하고, 요소를 교환할 때마다 1씩 증가시킴
  - 패스를 종료한(안쪽 for문의 반복이 완료된) 시점에서 exchg 값은 해당 패스의 교환 횟수
  - 패스를 종료한 시점에서 exchg값이 0이라면 정렬을 완료했다고 판단할 수 있으므로, break문에 의해 바깥쪽의 for문을 강제로 나와 함수를 종료

<br>

### 알고리즘 개선하기 2
- 새로운 배열 {1, 3, 9, 4, 7, 8, 6}을 버블 정렬하겠다.
  - 첫 번째 패스의 마지막 교환을 마치고 난 이후의 세 요소 {1, 3, 4}는 정렬된 상태
  - 이렇게 각 비교, 교환을 하다가 어떤 시점 이후에 교환하지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 좋다.
  - 따라서 두 번째 패스는 첫 요소를 제외한 6개가 아니라 4개의 요소를 비교, 교환하면 됨
- BubbleSort3
  - last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소(a[j])의 인덱스를 저장하기 위한 변수
  - 교환할 때마다 오른쪽 요소의 인덱스 값을 last에 저장
  - 하나의 패스를 마쳤을 때 last 값을 k에 대입하여 다음에 수행할 패스의 범위를 제한함
  - 다음 패스에서 마지막으로 비교할 두 요소는 a[k]와 a[k+1]이 됨
  - 이때 bubbleSort 메서드의 시작 부분에서 k값을 0으로 초기화하는 이유는 첫번째 패스에서 모든 요소를 검사해야 하기 때문

<br>

---

<br>

정리한 내용에 대한 저작권은 "[do it! 자료구조와 함께 배우는 알고리즘 입문 자바편 개정](https://www.aladin.co.kr/search/wsearchresult.aspx?SearchTarget=All&SearchWord=Do+it%21+%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80+%ED%95%A8%EA%BB%98+%EB%B0%B0%EC%9A%B0%EB%8A%94+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98+%EC%9E%85%EB%AC%B8+%3A+%EC%9E%90%EB%B0%94+%ED%8E%B8)"에 있습니다.