# Chapter06 정렬 알고리즘 - 04 단순 삽입 정렬
- 단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽의 걸맞는 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘

<br>

## 단순 삽입 정렬 알아보기
- 단순 삽입 정렬(straight insertion sort)은 트럼프 카드를 한 줄로 늘여놓을 때 사용하는 방법과 비슷한 방법의 알고리즘
- {6, 4, 1, 7, 3, 9, 8} 배열을 예로 살펴보겠다.
  - 단순 삽입 정렬은 두 번째 요소부터 선택하여 진행함
    - 4는 6보다 앞쪽에 위치해야 하므로 앞쪽에 삽입, 6을 오른쪽으로 옮기면 {4, 6, 1, 7, 3, 9, 8}이 됨
  - 3 번째 요소 1을 선택해 앞쪽에 삽입, 이후에도 계속해서 같은 작업을 수행함
- 정렬된 부분과 정렬되지 않은 부분으로 배열이 구성되어 있다고 생각하고, 다음 작업을 n-1회 반복하면 정렬을 마치게 됨
  ```
  아직 정렬되지 않은 부분의 첫 번째 요소를 정렬한 부분의 알맞은 위치에 삽입합니다.
  ```
- i를 1, 2, ..., n-1로 1씩 증가시키면서 인덱스가 i인 요소를 꺼내 정렬된 부분의 알맞은 곳에 삽입함
- 알고리즘의 개요는 다음과 같다.
  ```java
  for(int i=0; i<n; i++) {
    // tmp <- [i]
    // a[0], ..., a[i-1]의 알맞은 곳에 tmp 삽입
  }
  ```
- tmp에 a[i]를 대입(3을 선택)하고 반복제어용 변수 j에 i를 대입한 뒤 다음 두 조건 중 하나를 만족할 때까지 j를 1씩 감소시키면서 대입하는 작업을 반복
  ```
  1. 정렬된 열의 왼쪽 끝에 도달합니다.
  2. tmp보다 작거나 같은 key을 갖는 항목 a[j-1]을 발견합니다.
  ```
- 드모르간 법칙을 적용하면 다음 두 조건이 모두 성립될 때까지 반복하게 됨
  ```
  1. j가 0보다 큽니다.
  2. a[j-1] 값이 tml보다 큽니다.
  ```
- 이 과정을 마치고 난 뒤 요소 a[j]에 tmp를 대입하면 한 요소에 대한 단순 삽입 정렬을 마치게 됨
- InsertionSort
  - 이렇게 구현한 단순 삽입 정렬 알고리즘은 서로 떨어져 있는 요소들을 교환하는 것이 아니므로 안정적
  - 요소의 비교횟수와 교환 횟수는 n*n/2회
  - 단순 삽입 정렬을 셔틀 정렬(shuttle sort)라고도 함

<br>

### 단순 정렬의 시간 복잡도
- 지금까지 공부한 세 가지 단순 정렬(버블, 선택, 삽입)의 시간 복잡도는 모드 O(n*n)
- 효율이 좋지 않음